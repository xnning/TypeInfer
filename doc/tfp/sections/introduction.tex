\section{Introduction}

Dependent types are currently increasingly adopted in many language
designs due to its expressiveness \cite{xi1999dependent, licata2005formulation,
  pasalic2006concoqtion, mckinna2006dependent,
  norell2009dependently, brady2013idris}.
However, type inference or unification on those language is not easy.
This is because
more power a type system has, more sophisticated the type system
becomes. The dependency between expressions and types bring lots of complexities.

Existing literature \cite{ziliani2015unification, abel2011higher, elliott1989higher}
that tries to give specification for type inference
or unification of
a dependent language is quite complicated,
and even becomes non-intuitive or unpredictable once it involves
so many constructs or features.

In this paper, we presents an easy strategy to do unification based on
alpha-equality for first-order dependent
types. This algorithm is based on alpha-equality for following reasons. Firstly,
for unification algorithms based on beta-equality, if the system has strong
normalization, the algorithm usually reduces all types into normal forms and
then compares the normal forms using
alpha-equality.
Secondly, there are proposals for type system without strong
normalization, for example, doing type-level computations using casts
\cite{van2013explicit, kimmell2012equational, sjoberg2012irrelevance}
. For
those systems, the unification is naturally based on alpha-equality.

Our notations to do formalization are inspired by \cite{dunfield2013complete}.
We come up with a new
process called \textit{type sanitization} that helps resolve the dependency
problem. Later on, the type sanitization process is
extended to deal with restricted polymorphic types.
Based on type sanitization, our algorithm
are remarkably simple and well-behaved.
Though there are no formal proofs for the meta-theory of the system yet
(which is still in progress),
we give many conjectures that we believe are intuitive.

We expect our algorithm serves as a footstone towards
a simple and predictable unification/subtyping algorithm for
dependent types. This is also for
filling the gap between
delicate unification algorithms for simple types
and
sophisticated unification algorithms for dependent types.
A non-goal of our work
is to replace existing matured unification/subtyping algorithm.
More precisely, our main contributions are:

\begin{itemize}
  \item We come up with a strategy called \textit{type sanitization}
    that resolves the
    dependency between types.
  \item Based on type sanitization, we give a specification of an alpha-equality
    based unification algorithm
    for first-order dependent types.
  \item We show how to extend type sanitization for a specification of a
    subtyping algorithm
    in a language including restricted polymorphic types.
\end{itemize}

In Section \ref{sec:language}, we present a overview of a first-order dependently
typed language.
In Section \ref{sec:unification}, we formalize the unification
problem and present the type sanitization and unification. In
Section \ref{sec:extension}, we extend the language with
polymorphic types, and then present the process of extended type sanitization
along with subtyping rules. Finally Section \ref{sec:conclusion} concludes the
paper.