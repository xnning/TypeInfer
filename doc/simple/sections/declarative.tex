\section{Declarative System}

\begin{figure*}[h]
    \headercapm{\preall e:\tau \trto t}{Expression Typing ($\delta ::= \Inf\mid \Chk$)}
    \[\DAx \quad \DVar \quad \DLetVar \]
    \[\DAnn \quad \DLamInf \quad \DLamChk\]
    \[\DApp \quad \DPi\]
    \[\DLet\]
    \[\DCastUp \quad \DCastDn\]
    \[\DSub \quad \DConv\]
    \\
    \headercapm{\preinst \sigma \lt \tau}{Instantiation} \quad \headercapm{\pregen e : \sigma}{Generalization}
    \[\DInstantiation \quad \DGeneralization\]
    \caption{Declarative typing rules}
    \label{fig:decltyping}
\end{figure*}

\begin{figure}[t]
    \headercapm{[\ctx]e_1 = e_2}{Apply context to a type}

    \begin{mathpar}
    \begin{tabular}{r c l}
        $[\ctxinit]e$   & = & $e$       \\
        $[\ctx,x:\tau]e$ & = & $[\ctx]e$ \\
        $[\ctx,x:\sigma = \tau]e$ & = & $[\ctx](e[x\mapsto \tau])$ \\
    \end{tabular}
    \end{mathpar}
    \caption{Applying a context}
    \label{fig:declapplyctx}
\end{figure}

\begin{figure}[t]
    \begin{mathpar}
    \begin{tabular}{r c l}
        $FV(x)$   & = & $\{x\}$       \\
        $FV(\star)$    & = & $\varnothing$            \\
        $FV(e_1 ~ e_2)$    & = & $FV(e_1) \cup FV(e_2)$            \\
        $FV(\erlam x e)$   & = & $FV(e) - \{x\}$            \\
        $FV(\bpi x t e)$   & = & $FV(t) \cup FV(e) - \{x\}$            \\
        $FV(\kw{let} x = e_1 \kw{in} e_2)$  & = & $FV(e_1) \cup FV(e_2) - \{x\}$            \\
        $FV(\castupz e)$   & = & $FV(e)$            \\
        $FV(\castdn e)$    & = & $FV(e)$            \\
        $FV(e:t)$          & = & $FV(e) \cup FV(t)$            \\
    \end{tabular}
    \end{mathpar}
    \caption{Free variables}
    \label{fig:decl-free-variables}
\end{figure}

The typing rule for declarative system are shown in figure \ref{fig:decltyping}.

\paragraph{Bidirectional typing.} The judgement $\preall e:\sigma \trto t$ is interpreted as, under context $\ctx$, infer the type of the expression (with $\delta=\Inf$), which gives type $\tau$; or check the expression with type $\tau$ (if $\delta = \Chk$). Most typing rules are standard with respect to $\lambda C$ and bidirectional type checking.

\rul{D-Ax} is our impredicative axiom. \rul{D-Var} fetches type information from context for variables. \rul{D-LetVar} is the case for let binding, where we use \rul{D-Inst} to instantiate the type.

\rul{D-Ann} checks the expression with the provided type. \rul{D-Lam$\Inf$} gives $x$ a arbitrary type $\tau$ with ensuring $\tau$ is of type $\star$. \rul{D-Lam$\Chk$} continues to check the body with $x$ whose type is assigned as provided type. \rul{D-App} first infers the type of the function, and checks the argument satisfying parameter type, and substitutes the argument in the result type.

\rul{D-Let} generalizes the type of $e_1$ and store the type and the binding with $x$ in the context. The binding will be substituted in the result type. Which means, \lst{let a = int in \\x:a. x} is a well typed expression with type $\bpi x {int} {int}$ instead of $\bpi x a a $. Let has check mode because it needs to deliver the check type information. For example expression $(\kw{let} y = 3 \kw{in} \erlam f {(f~nat~1) + (f~\star~nat))}: (\bpi f {(\bpi x \star {\bpi y x nat})} nat)$.

\rul{D-Pi} checks the types in the pi type are all $\star$.

\rul{D-CastUp} shows $\ercastup$ can only be checked because there are unlimited possibility of $\tau_2$. \rul{D-CastDn} does one-step reduction on original type.

\rul{D-Sub} states that if the type of a expression could be infered, then it could be checked.

\paragraph{Contextual equivalence.} Instead of normal delta-rule($\delta$-reduction) used to deal with let binding, here we use contextual equivalence as shown in \rul{D-Conv}.

Using context as a substitution is defined in Figure \ref{fig:declapplyctx}, where let binding is the only form that will be applied. But as we will see soon, this notation extends smoothly in the algorithmic system. If two types are alpha-equal under context substitution of $\ctx$, we regard these two types contextual equivalence under $\ctx$.

Having these notations, we could see in the precondition of \rul{D-Conv}, the type of $e$ could be replaced with another type only if these two types are contextual equivalence under current context.

\paragraph{Polymorphism.} \rul{D-Inst} and \rul{D-Gen} are specialized forms of the ones in Implicit Calculus of Constructions (ICC), as types are just stars. One advantage of using this form of generalization instead of Hindley-Milner way is this rule helps get rid of type variables.

\rul{D-Inst} turns a polymorphic type into a monotype by instantiating all the variables bound by forall to expressions with type star. \rul{Gen} adds variables in context to infer the type, and extract them as forall in the result type.
