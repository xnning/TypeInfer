% Setup spaces between column
\setlength{\tabcolsep}{2pt}

\section{Specification}

% ------------------------------------------------------------------------
% SYNTAX
% ------------------------------------------------------------------------

\subsection{Syntax}
\begin{tabular}{lrcl}
Type & $\sigma$ & \syndef & $\forall x:\star. \sigma \mid \tau$ \\

Expressions & $e,\tau$ & \syndef & $x \mid \genA \mid \star \mid e_1~e_2$ \\
&& \synor & $\erlam x e \mid \blam x \tau e$ \\
&& \synor & $\bpi x {\tau_1} \tau_2$ \\
&& \synor & $\kw{let} x=e_1 \kw{in} e_2$ \\
&& \synor & $\ercastup e \mid \castdn e$ \\
&& \synor & $e : \tau$ \\
Contexts &
$\ctx,\ctxl,\ctxr$ & \syndef & $\ctxinit \mid \ctx,x \mid \ctx,x:\tau \mid \ctx,x:\tau=\tau_2$ \\
&& \synor & $\ctx,\genA \mid \ctx,\genA=\tau$ \\

Target Expr. & $t, s$ & \syndef & $x \mid \star \mid t_1~t_2$ \\
&& \synor & $\blam x {t_1} t_2 \mid \bpi x {t_1} t_2$ \\
&& \synor & $\castup {t_1} t_2 \mid \castdn t$\\
&& \synor & $\kw{let} x=t_1 \kw{in} t_2$ \\
&& \synor & $\unit \mid \Unit$ \\
Target Ctx. &
$\tctx$ & \syndef & $\ctxinit \mid x : t$ \\
\end{tabular}

\explain{Notes about $\sigma$:
\begin{itemize}
\item Sigma type is only generated by the system.
\item only rank-one.
\end{itemize}}

\explain{Notes about $\ercastup$ and $\castdn$:
\begin{itemize}
\item Type-level computation one step at a time.\\
$(\ercastup 3):((\erlam x x)~nat)$.\\
$\blam x {((\erlam a a)~nat)} {(\castdn x):nat}$
\item $\beta$ reduction must be explicit by using $\ercastup$ and $\castdn$. So type unification is based on $\alpha$ equality.
\end{itemize}}

\subsection{Algorithmic Typing}

% ------------------------------------------------------------------------
% TYPING RULES
% ------------------------------------------------------------------------

\newcommand*{\TAx}{\inferrule{ }{\preinf \star:\star \toctxo \trto \star}\rname{T-Ax}}
\newcommand*{\TVar}{\inferrule{x:\tau \in \ctx}{\preinf x:\tau \toctxo
  \trto x}\rname{T-Var}}
\newcommand*{\TLetVar}{\inferrule{x:\sigma = \tau \in \ctx \\ \preinst \sigma \lt \tau_2 \toctx}{\preinf x:\tau_2 \toctx
  \trto x}\rname{T-LetVar}}
\newcommand*{\TSub}{\inferrule{\preinf e : \tau_1 \toctx_1 \trto{t} \\ \ctxl_1 \byuni [\ctxl_1]\tau_1
    \lt [\ctxl_1]\tau_2 \toctx}{\prechk e:\tau_2 \toctx \trto{t}}\rname{T-Sub}}
\newcommand*{\TAnn}{\inferrule{\prechk \tau:\star \toctx_1 \\
    \ctxl_1 \bychk e:\tau \toctx \trto t}{\preinf (e:\tau):\tau \toctx
  \trto t}\rname{T-Ann}}
\newcommand*{\TLamInf}{\inferrule{\preinf[,\genA,x:\genA]
    e:\tau_2 \toctx, x:\genA, \ctxr \trto t}{\preinf \erlam x e : (\bpi x \genA
    [\ctxr]\tau_2) \toctx, \kw{Unsolved}(\ctxr) \trto {\blam x \genA t}}\rname{T-Lam$\Inf$}}
\newcommand*{\TLamChk}{\inferrule{\prechk[,x:\tau_1]
    e:\tau_2 \toctx,x:\tau_1,\ctxr \trto {t_2} \\ \prechk {\bpi x {t_1}
    \tau_2 : \star \toctx_1 \trto {\bpi x {t_1} t_3}}}{\prechk \erlam x e : \bpi x {\tau_1}
    \tau_2 \toctx \trto {\blam x {t_1} t_2}}\rname{T-Lam$\Chk$}}
\newcommand*{\TLamAnn}{\inferrule{\prechk \tau_1 : \star \toctx_1
    \trto {t_1} \\
    \ctxl_1,x:\tau_1 \byinf
    e:\tau_2 \toctx, x:\tau_1, \ctxr \trto {t_2}}{\preinf \blam x {\tau_1} e : (\bpi x {\tau_1}
    [\ctxr]\tau_2) \toctx, \kw{Unsolved}(\ctxr) \trto {\blam x {t_1} t_2}}\rname{T-LamAnn}}
\newcommand*{\TApp}{\inferrule{
    \preinf e_1 : \tau_1 \toctx_1 \trto {t_1} \\
    \ctxl_1 \byapp [\ctxl_1]\tau_1~e_2 : \tau_2 \toctx \trto {t_2} \\
}{\preinf e_1~e_2:\tau_2 \subst x
    {e_2} \toctx \trto {t_1~t_2}}\rname{T-App}}
\newcommand*{\TAppPi}{\inferrule{
    \preinf e_1 : \bpi x {\tau_1} \tau_2 \toctx_1 \\
    \ctxl_1 \bychk e_2 : [\ctxl_1]\tau_1 \toctx \\
}{\preinf e_1~e_2:\tau_2 \subst x
    {e_2} \toctx}\rname{T-AppPi}}
\newcommand*{\TAppVar}{\inferrule{
    \preinf e_1 : \genA \toctx_1[\genA] \\
    \ctxl_1[\genA_1,\genA_2,\genA=\bpi x {\genA_1} \genA_2] \bychk e_2 : \genA_1 \toctx \\
}{\preinf e_1~e_2:\genA_2 \toctx}\rname{T-AppVar}}
\newcommand*{\TPi}{\inferrule{\prechk \tau_1 : \star \toctx_1 \trto {t_1} \\
\ctxl_1,x:\tau_1 \bychk \tau_2 : \star \toctx,x:\tau_1,\ctxr \trto {t_2}}{\preinf \bpi x {\tau_1} {\tau_2} :
    \star \toctx \trto {\bpi x {t_1} t_2}}\rname{T-Pi}}
\newcommand*{\TLet}{\inferrule{\preinf e_1 : \tau_1 \toctx_1 \trto {t_1} \\
\pregen {\tau_1} \lt \sigma \\
\ctx, x:\sigma = e_1 \byall e_2 : \tau_2 \toctx, x:\sigma = e_1, \ctxr \trto {t_2}}{\preall \kw{let} x=e_1
\kw{in} e_2 : [x:\sigma=e_1, \ctxr]\tau_2 \toctx, \kw{Unsolved}(\ctxr) \\ \trto {\kw{let} x = t_1 \kw{in} t_2}}\rname{T-Let}}
\newcommand*{\TCastUp}{\inferrule{[\ctx]\tau_2
    \redto \tau_1 \\
    \prechk e : \tau_1 \toctx \trto {t_2} \\ \prechk \tau_1 : \star
    \toctx_1 \trto {t_1}}
  {\prechk \ercastup e : \tau_2 \toctx
    \trto {\castup {t_1} t_2}}\rname{T-CastUp}}
\newcommand*{\TCastDn}{\inferrule{\preinf e : \tau_1 \toctx \trto t \\
    [\ctxl]\tau_1 \redto \tau_2}{\preinf \castdn e : \tau_2
    \toctx \trto {\castdn t}}\rname{T-CastDn}}

% ------------------------------------------------------------------------
% UNIFICATION RULES
% ------------------------------------------------------------------------

\newcommand*{\UVar}{\inferrule{ }{\preuni[{[x]}] x \lt x \toctxo[x]}\rname{U-Var}}
\newcommand*{\UEVarId}{\inferrule{ }{\preuni[{[\genA]}] \genA \lt \genA \toctxo[\genA]}\rname{U-EVarId}}
\newcommand*{\UEVarTy}{\inferrule{\genA \not \in \fun{FV}(\tau_1) \\ \ctx[\genA] \bycg \tau_1 \cgto \tau_2 \toctx_1, \genA, \ctxl_2 \\ \ctxl_1 \bywt \tau_2}
{\ctx[\genA] \byuni \genA \lt \tau_1 \toctx_1, \genA=\tau_2, \ctxl_2}\rname{U-EvarTy}}
\newcommand*{\UTyEVar}{\inferrule{\genA \not \in \fun{FV}(\tau_1) \\ \ctx[\genA] \bycg \tau_1 \cgto \tau_2 \toctx_1, \genA, \ctxl_2 \\ \ctxl_1 \bywt \tau_2}
{\ctx[\genA] \byuni \tau_1 \lt \genA \toctx_1, \genA=\tau_2, \ctxl_2}\rname{U-TyEVar}}
\newcommand*{\UStar}{\inferrule{ }{\preuni \star \lt \star \toctxo}\rname{U-Star}}
\newcommand*{\UApp}{\inferrule{\preuni \tau_2 \lt \tau_2' \toctx_1 \\
    \ctxl_1 \byuni [\ctxl_1]\tau_1 \lt [\ctxl_1]\tau_1'
    \toctx}{\preuni \tau_1~\tau_2 \lt \tau_1'~\tau_2'
    \toctx}\rname{U-App}}
\newcommand*{\ULam}{\inferrule{\preuni[,x] \tau \lt \tau'
    \toctx,x,\ctxr}{\preuni \erlam x \tau \lt \erlam x \tau' \toctx}\rname{U-Lam}}
\newcommand*{\ULamAnn}{\inferrule{\preuni \tau_1 \lt \tau_3 \toctx_1 \\
    \ctxl_1, x:\tau_1 \byuni [\ctxl_1]\tau_2 \lt [\ctxl_1]\tau_4
    \toctx,x:\tau_1,\ctxr}{\preuni \blam x {\tau_1} \tau_2 \lt \blam x
    {\tau_3} \tau_4 \toctx}\rname{U-LamAnn}}
\newcommand*{\UPi}{\inferrule{\preuni \tau_1' \lt \tau_1 \toctx_1
    \\ \ctxl_1,x:\tau_1 \byuni [\ctxl_1]\tau_2 \lt [\ctxl_1]\tau_2'
    \toctx,x:\tau_1,\ctxr}{\preuni \bpi x {\tau_1} \tau_2 \lt \bpi x
    {\tau_1'} \tau_2' \toctx}\rname{U-Pi}}
\newcommand*{\ULet}{\inferrule{\preuni \tau_1 \lt \tau_1' \toctx_1
    \\ \ctxl_1, x \byuni {[\ctxl_1]}\tau_2 \lt [\ctxl_1]\tau_2'
    \toctx, x, \ctxr}{\preuni \kw{let} x ={\tau_1} \kw{in} \tau_2 \lt \kw{let} x=
    {\tau_1'} \kw{in} \tau_2' \toctx}\rname{U-Let}}
\newcommand*{\UCastUp}{\inferrule{\preuni \tau \lt \tau'
    \toctx}{\preuni \ercastup \tau \lt \ercastup \tau' \toctx}\rname{U-CastUp}}
\newcommand*{\UCastDn}{\inferrule{\preuni \tau \lt \tau'
    \toctx}{\preuni \castdn \tau \lt \castdn \tau' \toctx}\rname{U-CastDn}}
\newcommand*{\UAnn}{\inferrule{\preuni \tau \lt \tau' \toctx_1 \\
    \ctxl_1 \byuni [\ctxl_1]e \lt [\ctxl_1]e'
    \toctx}{\preuni e:\tau \lt e':\tau'
    \toctx}\rname{U-Ann}}

% ------------------------------------------------------------------------
% APPLICATION RULES
% ------------------------------------------------------------------------

\newcommand*{\APi}{\inferrule{\prechk e:\tau_1 \toctx \trto t}{\preapp (\bpi x
    {\tau_1} \tau_2)~e : \tau_2[x \mapsto e] \toctx \trto t}\rname{A-Pi}}
\newcommand*{\AEVar}{\inferrule{\prechk[{[\genA_2,\genA_1,\genA=\bpi x
    {\genA_1} \genA_2]}] e : \genA_1 \toctx \trto t}{\preapp[{[\genA]}]
  \genA~e : \genA_2 \toctx \trto t}\rname{A-EVar}}

% ------------------------------------------------------------------------
% TARGET TYPING RULES
% ------------------------------------------------------------------------

\newcommand*{\EAx}{\inferrule{ }{\pretar \star:\star \trto \star}\rname{E-Ax}}
\newcommand*{\EVar}{\inferrule{x:s \in \tctx}{\pretar x:s \trto
    x}\rname{E-Var}}
\newcommand*{\EApp}{\inferrule{\pretar t_1:\bpi x {s_1} {s_2} \trto {e_1} \\ \pretar
    t_2:s_1 \trto {e_2}}{\pretar t_1~t_2:s_2 \subst
  x {t_2} \trto {e_1~e_2}}\rname{E-App}}
\newcommand*{\ELam}{\inferrule{\pretar t_1:\star \trto {\tau_1} \\ \pretar[,x:t_1] t_2:s_1 \trto {e}
    }{\pretar \blam
    x {t_1} t_2 : \bpi x {t_1} {s_1} \trto {\blam x {\tau_1}
      e}}\rname{E-Lam}}
\newcommand*{\EPi}{\inferrule{\pretar t_1:\star \\ \pretar t_2:\star }{\pretar \bpi x {t_1} t_2 :
    \star \trto {\bpi x {\tau_1} \tau_2}}\rname{E-Pi}}
\newcommand*{\ECastUp}{\inferrule{\pretar t_1 : \star \\ \pretar t_2: s_1 \\ t_1 \redto s_1 }{\pretar \castup {t_1} {t_2} :t_1}\rname{E-CastUp}}
\newcommand*{\ECastDown}{\inferrule{\pretar t_1 : s_1 \\ s_1 \redto s_2 }{\pretar \castdn t_1 :s_2}\rname{E-CastDown}}
\newcommand*{\ELet}{\inferrule{\pretar x : s_1 \\ \pretar t_2[x \mapsto t_1] : s_2}{\pretar \kw{let} x = t_1 \kw{in} t_2:s_2}\rname{E-Let}}
\newcommand*{\EUnit}{\inferrule{ }{\pretar \unit: \Unit}\rname{E-$\unit$}}
\newcommand*{\EUnitTy}{\inferrule{ }{\pretar \Unit : \star}\rname{E-$\Unit$}}

% ------------------------------------------------------------------------
% POLYMORPHISM
% ------------------------------------------------------------------------

\newcommand*{\Instantiation}{\inferrule{\sigma = \forall{\overbar{x:\star}}. \tau}{\preinst \sigma \lt \tau[\overbar{x} \mapsto \overbar{\genA}] \toctx, \overbar{\genA}} \rname{Inst}}

\newcommand*{\Generalization}{\inferrule{\tau_2 = [\ctx]\tau \\ \overbar{\genA} = FV(\tau_2) - FV(\ctx)}{\pregen \tau \lt \forall \overbar{x:\star}. \tau_2[\overbar{\genA} \mapsto \overbar{x}]} \rname{Gen}}

% ------------------------------------------------------------------------
% UNIFY TVAR
% ------------------------------------------------------------------------

\newcommand*{\IVar}{\inferrule{ }{\ctx \bycg x \cgto x \toctxo}\rname{I-Var}}
\newcommand*{\IStar}{\inferrule{ }{\ctx \bycg \star \cgto \star \toctxo}\rname{I-Star}}
\newcommand*{\IEVarA}{\inferrule{ }{\ctx[\genB][\genA] \bycg \genB \cgto \genB \toctxo[\genB][\genA]}\rname{I-EVar1}}
\newcommand*{\IEVarB}{\inferrule{ }{\ctx[\genA][\genB] \bycg \genB \cgto \genA_1 \toctxo[\genA_1, \genA][\genB=\genA_1]}\rname{I-EVar2}}
\newcommand*{\IOthers}{\inferrule{\ctx \bycg \tau_0 \cgto \tau_0' \toctx_1 \\ \ctxl_i \bycg [\ctxl_i]\tau_i \cgto \tau_i' \toctx_{i+1}}{\ctx \bycg T\ \overbar{\tau_n} \cgto T\ \overbar{\tau_n'}}\rname{I-Other}}

% ------------------------------------------------------------------------
% EXPLAINATION
% ------------------------------------------------------------------------

\newcommand*{\OLamInf}{\inferrule{\prechk[,\genA,\genB,x:\genA]
    e:\genB \toctx, x:\genA, \ctxr}{\preinf \erlam x e : (\bpi x \genA
    \genB) \toctx}\rname{$\rightarrow$ I $\Rightarrow$}}
\newcommand*{\ALamInf}{\inferrule{\prechk[,\genA,x:\genA,\genB]
    e:\genB \toctx, x:\genA, \ctxr}{\preinf \erlam x e : (\bpi x \genA
    [\ctxr]\genB) \toctx, \kw{Unsolved}(\ctxr)}\rname{T-Lam$\Inf$-Alter}}

\newcommand*{\ExLamInf}{\explain{Changes compared to the original rule: \OLamInf \\
\begin{itemize}
\item the order of $\genB$ in precondition seems incorrect.\\
Expression $\erlam x {\blam y x y}$ should be of type $\bpi x \star {\bpi y x x}$, which mean $x$ will appear in $\genB$ in a dependent type function, so the order in the precondition should be $\genA, x:\genA, \genB$
\item How to throw away context if $\genB$ appears after $x$?\\
A possible solution is to apply the env to $\genB$ to get the result and collect the information for unsolved type variables, then we can safely throw away the context.
\item Then no need to have $\genB$.\\
Just infer the type of $e$ since now $\genB$ is of no use.\\
If we still want $\genB$, we could have an alternative rule:\\
$\ALamInf$
\item Minimize context.\\
We can minimize the context if replace $Unsolved(\ctxr)$ with $Unsolved(\ctxr) \cap FV([\ctxr]\tau_2)$, where FV is the free type variables.
\end{itemize}}}

\newcommand*{\ExLet}{\explain{Notes about Let:\\
\begin{itemize}
\item Generalization.\\
As in Damas-Milner type inference, we will do polymorphic generalization at let-binding.
\item Store definition.\\
Program $\kw{let} f = nat \kw{in} \blam x f {x + 3}$ is a valid program only if we know $x:f$ is equal to $x:nat$ when infer $x + 3$. So the definition of let-binding will be stored in the context. Let-binding will be substituted as tvar when apply the context.
\item Let has check mode because it needs to deliver the check type information. For example expression $(\kw{let} y = 3 \kw{in} \erlam f {(f~nat~1) + (f~char~'c'))}: (\bpi f {(\bpi x \star {\bpi y x nat})} nat)$
\end{itemize}
}}

\newcommand*{\ExCast}{\explain{Notes about $\ercastup$ and $\castdn$:\\
\begin{itemize}
\item $\ercastup$ can only be checked because there are unlimited possibility of $\tau_2$.
\item Context needs to be applied before the reduction.
\end{itemize}
}}

\newcommand*{\ExApp}{\explain{Notes about App:\\
\begin{itemize}
\item Substitute $e$ in the result type in rule A-Pi.
\item Rule A-EVar only resolve non-dependent function type for $\genA$, which means there is no $x$ in $\genA_2$.
\end{itemize}
}}

\newcommand*{\ExUPi}{\explain{Notes about UPi:\\
\begin{itemize}
\item The order of $x$ in the context determines the unification $\genA_2 \byuni \bpi x \star \genA_2 \lt \bpi x \star x$ will fail. Same goes for other unification rules involving adding $x$ in context.
\end{itemize}
}}

\newcommand*{\OInstRArr}{\inferrule{\preuni[{[\genA_2, \genA_1, \genA = \genA_1 \to \genA_2]}] \genA_1 \lt A_1 \toctx_1 \\
    \ctxl_1 \byuni [\ctxl_1]A_2 \lt \genA_2 \toctx} {\preuni[{[\genA]}] \genA \lt A_1 \to A_2 \toctx}\rname{InstRArr}}

\newcommand*{\ExUTyEVar}{\explain{Notes about UEVarTy and UTyEVar:\\
\begin{itemize}
\item What will happen when $\ctx \byuni \genA \lt \bpi x {\tau_1} {\tau_2}$?\\
original rule:\newline
\OInstRArr\\
  \begin{itemize}
  \item Normal function: $\ctx \byuni \genA \lt \bpi x \star \star$.\\
      Original rule is fine and results in $\genA = \bpi x \star \star$.
  \item Dependent function: $\ctx, \genA, \ctxr \byuni \genA \lt \bpi x \star x$.\\
      Here we want $x$ be able to appear in $\genA_2$.\\
      But we cannot add $x$ directly before $\genA_2$ because it makes all the type variables in $\ctxr$ be able to refer to $x$.\\
      One thought is we know $\bpi x \star x$ is well typed under $\ctx$ so can be assigned to $\genA$ directly. How about we only check type wellness? It cannot work.
  \item Dependent function involving type variables: $\ctx, \genA, \genB, \ctxr \byuni \genA \lt \bpi x \genB x.$\\
      Here $\bpi x \genB x$ is not well typed in $\ctx$.\\
      But it do have a solution context: $\ctx, \genA_1, \genA = \bpi  x {\genA_1} x, \genB = \genA_1, \ctxr$
  \item So we cannot destruct $\genA$ into $\genA_1 \to \genA_2$. And we cannot only rely on type wellness.\\
      One solution is we traverse the whole type on the right hand side and turn it to a type that is not bothered by the order of type variables.\\
      This is what the I-rules do.\\
      Then we could do the well type check safely.
  \end{itemize}
\item This rule already includes the cases EVar-EVar-Left, EVar-Evar-Right, EVar-Ty, Ty-EVar, EVar-Pi, Pi-EVar.
\end{itemize}
}}

\newcommand*{\ExIRules}{\explain{Notes about I-Rules:\\
\begin{itemize}
\item The only interesting cases are I-EVar1 and I-EVar2.\\
I-EVar1 is when $\genB$ appears before $\genA$, so it is safe to remain it.\\
But in I-EVar2, because $\genB$ cannot be refered to directly, so we create $\genA_1$  before $\genA$ and make $\genB=\genA_1$. And return $\genA_1$ as result.
\item Other cases are just structural.
\item An interpretation of I-Evar2 rule is that it is the combination of original InstRArr and InstRReach rules in Figure 10, which create new type variable and make $\genB$ refer to it. Here it is adapted to fit dependent type.
\end{itemize}
}}

% ------------------------------------------------------------------------
% REAL PRINT
% ------------------------------------------------------------------------

\headercapm{\preall e:\tau \toctx \trto t}{Expression Typing ($\delta ::= \Inf\mid \Chk$)}
\[\TAx \quad \TVar\]
\[\TLetVar\]
% \[\TAppPi\]
% \[\TAppVar\]
\[\TApp\]
\[\TLamInf\]
\ExLamInf
\[\TLamChk\]
\[\TLamAnn\]
\[\TPi\]
\[\TLet\]
\ExLet
\[\TCastUp\]
\[\TCastDn\]
\ExCast
\[\TAnn\]
\[\TSub\]
\\
\headercapm{\preapp \tau_1~e:\tau_2 \toctx \trto t}{Application Typing}
\[\APi\]
\[\AEVar\]
\ExApp

\headercapm{\preinst \sigma \lt \tau \toctx}{Instantiation}
\[\Instantiation\]

\headercapm{\pregen \tau \lt \sigma}{Generalization}
\[\Generalization\]

\headercapm{\preuni \tau_1 \lt \tau_2 \toctx}{Unification of Types}
\[\UVar\]
\[\UEVarId\]
\[\UEVarTy\]
\[\UTyEVar\]
\ExUTyEVar
\[\UStar\]
\[\UApp\]
\[\ULam\]
\[\ULamAnn\]
\[\UPi\]
\ExUPi
\[\ULet\]
\[\UCastUp\]
\[\UCastDn\]
\[\UAnn\]

\headercapm{\ctx[\genA] \bycg \tau_1 \cgto \tau_2 \toctx}{$\ctx \byuni \genA \lt \tau_1$ results to $\genA = \tau_2$}

\[\IVar\]
\[\IStar\]
\[\IEVarA\]
\[\IEVarB\]
\[\IOthers\]
\ExIRules

% \subsection{Target Typing}
% \headercapm{\pretar t_1 : t_2 \trto e}{Target Typing}
% \[\EAx \quad
% \EVar\]
% \[\EApp\]
% \[\ELam\]
% \[\EPi\]
% \\

% ------------------------------------------------------------------------
% EXAMPLES
% ------------------------------------------------------------------------

\newpage

\begin{figure}

\subsection{Examples}

\begin{itemize}
\item Derivation of $(\erlam x x)~3$.
\[\small
\inferrule{{\inferrule{\inferrule{x:\genA \in \genA, x:\genA}
                                {\genA, x:\genA \byinf x:\genA \dashv \genA, x:\genA}\rname{T-Var}}
                     {\byinf \erlam x x : \bpi x \genA \genA \dashv \genA}\rname{T-Lam$\Inf$}} \quad
            \inferrule{\inferrule{\genA \byinf 3: \Int \quad
                                  \inferrule{\genA \notin FV(\Int) \\ \genA \bycg \Int \cgto \Int \\ \emptyset \bywt \Int}
                                            {\genA \byuni \Int \lt \genA \dashv \genA = \Int}\rname{U-TyEVar}}
                                 {\genA \bychk 3: \genA \dashv \genA = \Int}\rname{T-Sub}}
                      {\genA \byapp \bpi x \genA \genA ~ 3 :\genA \dashv \genA = \Int }\rname{A-Pi}}
          {\byinf (\erlam x x)~3:\genA \dashv \genA = \Int}\rname{T-App}
\]
\item Derivation of $\kw{let} f = \Int \kw{in} \blam x f {x+3}$.\\
Let $\ctx$ be $f:\star = \Int, x:f$\\
Arrow type is used to dispaly non dependent function type.
\[\small
\inferrule{\byinf \Int:\star \quad
           \bygen \star \lt \star \quad
           \inferrule{\inferrule{\inferrule{\ctx \byinf + : \ldots \quad
                                            \inferrule{\inferrule{\ctx \byinf x:f \quad
                                                                  [\ctx]f = \Int \quad
                                                                  \ctx \byuni \Int \lt \Int }
                                                                 {\ctx \bychk x:\Int \dashv \ctx}\rname{T-Sub}}
                                           {\ctx \byapp \Int \to \Int \to \Int ~ x: \Int \to \Int \dashv \ctx}\rname{A-Pi}}
                                           {\ctx \byinf x + : \Int \to \Int \dashv \ctx}\rname{T-App} \quad
                                 \inferrule{\ldots}
                                           {\ctx \byapp \Int \to \Int ~ 3 }\rname{A-Pi}}
                                {\ctx \byinf x + 3 :\Int \dashv \ctx}\rname{T-App}}
                     {f:\star = \Int \byinf \blam x f {x+3} : f \to \Int \vdash f:\star = \Int}\rname{T-LamAnn}
           }
          {\kw{let} f = \Int \kw{in} \blam x f {x+3} : [f:\star=\Int] (f \to \Int) \vdash \emptyset }\rname{T-Let}
\]
\end{itemize}

\end{figure}

\newpage

\subsection{Target Declarative Typing}

\[\EAx \quad \EVar\]
\[\EUnit \quad \EUnitTy\]
\[\EApp\]
\[\ELam\]
\[\EPi\]
\[\ECastUp\]
\[\ECastDown\]
\[\ELet\]

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
