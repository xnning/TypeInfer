\section{Language Overview}

\begin{figure}[h]
    \begin{tabular}{lrcl}
        Type & $\sigma$ & \syndef & $\forall x:\star. \sigma \mid \tau$ \\

        Expr & $e,\tau$ & \syndef & $x \mid \genA \mid \star \mid e_1~e_2$ \\
        && \synor & $\erlam x e \mid \blam x \tau e \mid \bpi x {\tau_1} \tau_2$ \\
        && \synor & $\kw{let} x=e_1 \kw{in} e_2$ \\
        && \synor & $\ercastup e \mid \castdn e$ \\
        && \synor & $e : \tau$ \\
        Contexts &
        $\ctx,\ctxl,\ctxr$ & \syndef & $\ctxinit$ \\
        && \synor & $\ctx,x \mid \ctx,x:\tau \mid \ctx,x:\tau=e$ \\
        && \synor & $\ctx,\genA \mid \ctx,\genA=\tau$ \\
        %Complete Ctx &
        %$\cctx$ & \syndef & $\ctxinit \mid \ctx,x \mid \ctx,x:\tau$ \\
        %&& \synor & $\ctx,x:\tau=\tau_2$ \\
        %&& \synor & $\ctx,\genA=\tau$ \\
    \end{tabular}
    \caption{syntax.}
    \label{fig:syntax}
\end{figure}

\begin{figure}[h]
    \[\SBetaA\]
    \[\SBetaB\]
    \[\SCastDownUp\]
    \[\SApp\]
    \[\SCastDown\]
    \[\SAnn\]
    \[\SLet\]
    \caption{Operational semantics.}
    \label{fig:operational}
\end{figure}

Figure \ref{fig:syntax} shows the syntax of the system.

\paragraph{Expression.} Expressions $e$ are variables x, existential
type variables $\genA$, a single sort $\star$ to represent the type of
types, functions without annotations $\erlam x e$ and with annotations
$\blam x \tau e$, application $e_1~e_2$, Pi type
$\bpi x {\tau_1} {\tau_2}$, let expression
$\kw{let} x = e_1 \kw{in} e_2$, cast up and cast down, and expression
with annotation $e:\tau$.

In $\lambda C$, there are two distinct sorts $\star$ and $\square$
representing the type of types and sorts respectively, and an axiom
$\star:\square$ specifying the relationship between these two. Here we
further merge types and kinds together by including only a single sort
$\star$ with an impredicative axiom $\star:\star$. This choice loses 
strong normalization and logical consistency, which is ok for our 
own purposes: we intend to use the calculus for programming, not
theorem proving. However, keeping the stratification between the two 
sorts should be possible too.



Figure \ref{fig:operational} shows the call-by-name operational
semantic, defined by one-step reduction. \rul{S-Beta1} and
\rul{S-Beta2} are for beta reduction and \rul{S-CastDownUp} is for
cast canceling. \rul{S-App}, \rul{S-CastDown} and \rul{S-Ann} are
inductive cases. \rul{S-Let} show the operational semantics for let is
defined by substitution.

\paragraph{Type.} Types $\sigma$ include monotypes $\tau$ which are
the same as expressions, and a rank-one polymorphism type
$\forall x:\star. \sigma$. Polymorphic types are only generated by the
type system and do not appear at the expression level.

\paragraph{Context.} A context is a ordered list of variables and
existential type variables. There are three forms of variables: the
simplest one $x$, $x:\tau$ with a type
annotation, and a let binding $x:\tau=e$ with both a type annotation
and a definition. Existential type variables are either in unsolved form
$\genA$ or solved form $\genA = \tau$.

The order in context is important for solving dependencies. Back to the example in introduction:
\begin{lstlisting}
let f = \a. \b:a. b in \x. \y. f y x.
\end{lstlisting}
Having the order, we easily know that $x$ cannot be of type $y$ because $y$ is after $x$ in the context.

Figure \ref{fig:wellform} gives the definition of well formedness of a context and a expression under context.

\begin{figure}[h]
    \headercapm{\ctx \bywt e}{Well Form of $e$ under context $\ctx$}

    \[\WFVar \quad \WFEVar \quad \WFStar\]
    \[\WFApp \quad \WFLam\]
    \[\WFLamAnn \quad \WFPi\]
    \[\WFLet \quad \WFCastUp\]
    \[\WFCastDown \quad \WFAnn\]

    \headercapm{\ctx\wc}{Context $\ctx$ is well formed}

    \[\WCEmpty \quad \WCVar\]
    \[\WCTypedVar\]
    \[\WCLetVar\]
    \[\WCEVar\]
    \[\WCSolvedEVar\]
    \caption{Well formedness}
    \label{fig:wellform}
\end{figure}
