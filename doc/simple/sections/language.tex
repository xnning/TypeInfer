\section{Language Overview}

\begin{figure}[h]
    \begin{tabular}{lrcl}
        Type & $\sigma$ & \syndef & $\typA \mid e$ \\

        Expr & $e$ & \syndef & $x \mid \star \mid e_1~e_2$ \\
        && \synor & $\erlam x e \mid \bpi x {\sigma_1} \sigma_2$ \\
        && \synor & $\ercastup e \mid \castdn e$ \\
        && \synor & $e : \sigma$ \\
        && \synor & $\forall \typA: \star. \sigma$ \\
        Monotype & $\tau$ & \syndef & $ \{ \sigma' \in \sigma, \forall \notin \sigma'\} $ \\
        Contexts &
        $\dctx$ & \syndef & $\ctxinit \mid \dctx, \typA \mid \dctx, x \mid \dctx,x:\sigma$ \\
    \end{tabular}
    \caption{Declarative syntax.}
    \label{fig:declsyntax}
\end{figure}

\begin{figure}[h]
    \[\SBetaA\]
    \[\SCastDownUp\]
    \[\SApp\]
    \[\SCastDown\]
    \[\SAnn\]
    \[\SLet\]
    \caption{Operational semantics (Call by name).}
    \label{fig:operational}
\end{figure}

Figure \ref{fig:declsyntax} shows the syntax of the system.

\paragraph{Expression.} Expressions $e$ are variables x, a single sort $\star$ to represent the type of
types, function $\erlam x e$
, application $e_1~e_2$, Pi type
$\bpi x {\tau_1} {\tau_2}$, let expression
$\kw{let} x = e_1 \kw{in} e_2$, cast up and cast down, and expression
with annotation $e:\tau$.

In $\lambda C$, there are two distinct sorts $\star$ and $\square$
representing the type of types and sorts respectively, and an axiom
$\star:\square$ specifying the relationship between these two. Here we
further merge types and kinds together by including only a single sort
$\star$ with an impredicative axiom $\star:\star$. This choice loses
strong normalization and logical consistency, which is ok for our
own purposes: we intend to use the calculus for programming, not
theorem proving. However, keeping the stratification between the two
sorts should be possible too.


Figure \ref{fig:operational} shows the call-by-name operational
semantic, defined by one-step reduction. \rul{S-Beta1}
is for beta reduction and \rul{S-CastDownUp} is for
cast canceling. \rul{S-App}, \rul{S-CastDown} and \rul{S-Ann} are
inductive cases. \rul{S-Let} show the operational semantics for let is
defined by substitution.

\paragraph{Type.} Types scheme $\sigma$ is a rank-one polymorphism type $\forall x:\star. \sigma$ and
includes monotypes $\tau$ which are
the same as expressions. Polymorphic types are only generated by the
type system and do not appear at the expression level.

\paragraph{Context.} A context is a ordered list of variables, which has
two forms: $x:\tau$ with a type annotation, and a let binding $x:\tau=e$ with both a type annotation and a definition.

The order in context is important for solving dependencies. Back to the example in introduction:
\begin{lstlisting}
let f = \a. \b:a. b in \x. \y. f y x.
\end{lstlisting}
Having the order, we easily know that $x$ cannot be of type $y$ because $y$ is after $x$ in the context.

Figure \ref{fig:wellform} gives the definition of well formedness of a context and a type under context, which refers to typing rules that will be introduced later.

\begin{figure}[h]
    \headercapm{\dctx\wc}{Context $\dctx$ is well formed}

    \[\WCEmpty\]
    \[\WCTVar\]
    \[\WCTypedVar\]
    \caption{Well formedness}
    \label{fig:wellform}
\end{figure}
