\section{Language Overview}

\begin{figure}[h]
    \begin{tabular}{lrcl}
        Type & $\sigma$ & \syndef & $\forall x:\star. \sigma \mid \tau$ \\

        Expr & $e,\tau$ & \syndef & $x \mid \star \mid e_1~e_2$ \\
        && \synor & $\erlam x e \mid \bpi x {\tau_1} \tau_2$ \\
        && \synor & $\kw{let} x=e_1 \kw{in} e_2$ \\
        && \synor & $\ercastup e \mid \castdn e$ \\
        && \synor & $e : \tau$ \\
        Contexts &
        $\ctx,\ctxl,\ctxr$ & \syndef & $\ctxinit \mid \ctx,x:\tau \mid \ctx,x:\sigma=e$ \\
    \end{tabular}
    \caption{Declarative syntax.}
    \label{fig:declsyntax}
\end{figure}

\begin{figure}[h]
    \[\SBetaA\]
    \[\SCastDownUp\]
    \[\SApp\]
    \[\SCastDown\]
    \[\SAnn\]
    \[\SLet\]
    \caption{Operational semantics.}
    \label{fig:operational}
\end{figure}

Figure \ref{fig:declsyntax} shows the syntax of the system.

\paragraph{Expression.} Expressions $e$ are variables x, a single sort $\star$ to represent the type of
types, functions without annotations $\erlam x e$ and with annotations
$\blam x \tau e$, application $e_1~e_2$, Pi type
$\bpi x {\tau_1} {\tau_2}$, let expression
$\kw{let} x = e_1 \kw{in} e_2$, cast up and cast down, and expression
with annotation $e:\tau$.

In $\lambda C$, there are two distinct sorts $\star$ and $\square$
representing the type of types and sorts respectively, and an axiom
$\star:\square$ specifying the relationship between these two. Here we
further merge types and kinds together by including only a single sort
$\star$ with an impredicative axiom $\star:\star$. This choice loses
strong normalization and logical consistency, which is ok for our
own purposes: we intend to use the calculus for programming, not
theorem proving. However, keeping the stratification between the two
sorts should be possible too.



Figure \ref{fig:operational} shows the call-by-name operational
semantic, defined by one-step reduction. \rul{S-Beta1} and
\rul{S-Beta2} are for beta reduction and \rul{S-CastDownUp} is for
cast canceling. \rul{S-App}, \rul{S-CastDown} and \rul{S-Ann} are
inductive cases. \rul{S-Let} show the operational semantics for let is
defined by substitution.

\paragraph{Type.} Types $\sigma$ include monotypes $\tau$ which are
the same as expressions, and a rank-one polymorphism type
$\forall x:\star. \sigma$. Polymorphic types are only generated by the
type system and do not appear at the expression level.

\paragraph{Context.} A context is a ordered list of variables, which has
three forms: the simplest one $x$, $x:\tau$ with a type annotation, and a let binding $x:\tau=e$ with both a type annotation and a definition.

The order in context is important for solving dependencies. Back to the example in introduction:
\begin{lstlisting}
let f = \a. \b:a. b in \x. \y. f y x.
\end{lstlisting}
Having the order, we easily know that $x$ cannot be of type $y$ because $y$ is after $x$ in the context.

Figure \ref{fig:wellform} gives the definition of well formedness of a context and a type under context.

\begin{figure}[h]
    \headercapm{\ctx \bywt \sigma}{Well Form of type $\sigma$ under context $\ctx$}

    \[\WFPoly \quad \WFOther\]

    \headercapm{\ctx\wc}{Context $\ctx$ is well formed}

    \[\WCEmpty\]
    \[\WCTypedVar\]
    \[\WCLetVar\]
    \caption{Well formedness}
    \label{fig:wellform}
\end{figure}
