\section{Algorithmic Typing}

Declarative system servers well as a specification. However, in order to make type system practical, we cannot keep guessing types: as an example notice the $\tau_1$ in rule \rul{D-Lam$\Chk$} comes from nowhere.

One of main contributions of our work is a simple and deterministic algorithmic system, which could work as an algorithm for solving unknown types. We adopt the same notation as in Dunfield's work, the existential variable that represents types to be solved later. It brings more subtlety in a dependently typed calculus, but as we will see, things are not getting that complex.

\subsection{Language}

\begin{figure}[h]
    \begin{tabular}{lrcl}
        Type Scheme & $\sigma$ & \syndef & $\forall x:\star. \sigma \mid \tau$ \\

        Expr & $e,\tau$ & \syndef & $x \mid \genA \mid \star \mid e_1~e_2$ \\
        && \synor & $\erlam x e \mid \bpi x {\tau_1} \tau_2$ \\
        && \synor & $\kw{let} x=e_1 \kw{in} e_2$ \\
        && \synor & $\ercastup e \mid \castdn e$ \\
        && \synor & $e : \tau$ \\
        Contexts &
        $\tctx,\ctxl,\ctxr$ & \syndef & $\ctxinit$ \\
        && \synor & $\tctx,x \mid \tctx,x:\tau \mid \tctx,x:\sigma=e$ \\
        && \synor & $\tctx,\genA \mid \tctx,\genA=\tau$ \\
        Complete Ctx &
        $\cctx$ & \syndef & $\ctxinit \mid \cctx,x \mid \cctx,x:\tau$ \\
        && \synor & $\cctx,x:\tau=\tau_2$ \\
        && \synor & $\cctx,\genA=\tau$ \\
    \end{tabular}
    \caption{syntax.}
    \label{fig:algo-syntax}
\end{figure}

Figure \ref{fig:algo-syntax} gives the syntax of type and expression, and the definition of context for algorithmic system. The main difference is the existential variable $\genA$, which is quite like unification variables that are waited to be solved. But as context is ordered, unlike unification variables, existential variables also have scopes.

There are two forms of existential variables in context: unsolved form $\genA$ and solved form $\genA=\tau$. Once an existential vairable is solved, its solution will never be changed.

\begin{figure}[h]
    \headercapm{\tctx \bywt \sigma}{Well Term of type $\sigma$ under context $\tctx$}
    \[\TWTVar \quad \TWTEVar \quad \TWTStar\]
    \[\TWTPoly \quad \TWTApp\]
    \[\TWTLam \quad \TWTPi\]
    \[\TWTLet \quad \TWTCastUp\]
    \[\TWTCastDn \quad \TWTAnn\]

    \headercapm{\tctx \bywf \sigma}{Well Form of type $\sigma$ under context $\tctx$}

    \[\TWFPoly \quad \TWFOther \]

    \headercapm{\tctx\wc}{Context $\tctx$ is well formed}

    \[\TWCEmpty \quad \TWCVar\]
    \[\TWCTypedVar\]
    \[\TWCLetVar\]
    \[\TWCEVar\]
    \[\TWCSolvedEVar\]
    \caption{Well formedness with existential variables.}
    \label{fig:existwellform}
\end{figure}

The change of corresponding well formedness for existential variables and context, with a new notation well-termedness are given in Figure \ref{fig:existwellform}. Well-termedness $\tctx \bywt \sigma$ means under context $\tctx$, $\sigma$ is a syntactically legal term with all variables bounded, but it does not concern about type. The usage of well-termedness will become clear when we get into unification rules. Well formedness of a type now take existential variables into consideration. Existential variable is a well-formed type if it is contained in the context. An expression which is not a Pi type or a type scheme, is well-formed if it can be checked with $\star$.

Context substitution is extended smoothly with existential variables, as shown in Figure \ref{fig:applyctx}. Intuitively, once an existential variables is solved, we could substitute it with its solution. Different from declarative system, context substitution plays a more important role in algorithmic system, since some procedures only accept fully substituted expressions.

In algorithmic system, we will use FEV to stands for free existential variables in a type. The definition is given in Figure \ref{fig:algo-free-variables}. FEV of a context collects all FEV in type annotations, and does not include let binding and existential solutions.

\begin{figure}[t]
    \headercapm{[\tctx]e_1 = e_2}{Apply context to a type}

    \begin{mathpar}
    \begin{tabular}{r c l l}
        $[\ctxinit]e$   & = & $e$       \\
        $[\tctx,x]e$      & = & $[\tctx]e$ \\
        $[\tctx,x:\tau]e$ & = & $[\tctx]e$ \\
        $[\tctx,x:\sigma = \tau]e$ & = & $[\tctx](e[x\mapsto \tau])$ \\
        $[\tctx, \genA]e$ & = & $[\tctx]e$ \\
        $[\tctx, \genA=\tau]e$ & = & $[\tctx](e[\genA \mapsto \tau])$
    \end{tabular}
    \end{mathpar}
    \caption{Applying a context with existential variables.}
    \label{fig:applyctx}
\end{figure}

\begin{figure}[t]
    \headercapm{FEV(e)}{free existential variables of a type}
        \begin{mathpar}
        \begin{tabular}{r c l}
            $FEV(\genA)$        & = & $\{\genA\}$       \\
            $FEV(x)$            & = & $\varnothing$       \\
            $FEV(\star)$        & = & $\varnothing$            \\
            $FEV(e_1 ~ e_2)$    & = & $FEV(e_1) \cup FEV(e_2)$            \\
            $FEV(\erlam x e)$   & = & $FEV(e)$            \\
            $FEV(\bpi x t e)$   & = & $FEV(t) \cup FEV(e)$            \\
            $FEV(\kw{let} x = e_1 \kw{in} e_2)$  & = & $FEV(e_1) \cup FEV(e_2)$            \\
            $FEV(\castupz e)$   & = & $FEV(e)$            \\
            $FEV(\castdn e)$    & = & $FEV(e)$            \\
            $FEV(e:t)$          & = & $FEV(e) \cup FEV(t)$            \\
            $FEV(\forall x:\star. \sigma)$     & = & $FEV(\sigma)$            \\
        \end{tabular}
        \end{mathpar}

    \headercapm{FEV(\tctx)}{free existential variables of context}
        \begin{mathpar}
        \begin{tabular}{r c l}
            $FEV(\tctx, x)$        & = & $FEV(\tctx)$       \\
            $FEV(\tctx, x:\tau)$   & = & $FEV(\tctx) \cup FEV(\tau)$       \\
            $FEV(\tctx, x:\sigma = \tau)$     & = & $FEV(\tctx) \cup FEV(\sigma) $       \\
            $FEV(\tctx, \genA)$        & = & $FEV(\tctx)$       \\
            $FEV(\tctx, \genA=\tau)$   & = & $FEV(\tctx)$       \\
        \end{tabular}
        \end{mathpar}
    \caption{Free existential variables.}
    \label{fig:algo-free-variables}
\end{figure}

\paragraph{Hole notation.} We keep the same hole notations like $\tctx[x]$ to require the variable $x$ appear in the context, sometimes also written as $\tctx_1, x, \tctx_2$. According to this definition, the precondition of \rul{WF-EVar} could be removed and the conclusion is replaced by $\tctx[\genA] \bywf \genA$.

Multiple holes also keep the order. For example, $\tctx[x][\genA]$ not only require the existance of both variable $x$ and $\genA$, and also $x$ appear before $\genA$.

Hole notation is also used for replacement and modification. Later in the unification rules, we will see situations where $\tctx[\genA]$ could become $\tctx[\genA = \star]$, which means the context keeps unchanged except $\genA$ now is solved.

\subsection{Algorithmic Typing}

\begin{figure*}[h]
    \headercapm{\tpreall e:\tau \toctx \trto t}{Expression Typing ($\delta ::= \Inf\mid \Chk$)}
    \[\TAx \quad \TVar \quad \TLetVar \quad \TEVar\]
    \[\TAnn \quad \TPi\]
    \[\TLamInf \quad \TLamChk\]
    \[\TLet\]
    \[\TCastUp \quad \TCastDn\]
    \[\TApp \quad \TSub\]
    \\
    \headercapm{\tpreapp \tau_1~e:\tau_2 \toctx \trto t}{Application Typing}
    \[\APi \quad \AEVar\]
    \\
    \headercapm{\tpreinst \sigma \lt \tau \toctx}{Instantiation} \quad \headercapm{\tpregen \tau \lt \sigma}{Generalization}
    \[\Instantiation \quad \Generalization\]
    \caption{Typing rules}
    \label{fig:algo-typing-rules}
\end{figure*}

\begin{figure*}[h]
\headercapm{\tpreuni \tau_1 \lt \tau_2 \toctx}{Unification of Types}
    \[\UVar \quad \UEVarId \quad \UStar\]
    \[\UApp \quad \ULet\]
    \[\ULam \quad \UCastUp \quad \UCastDn\]
    \[\UPi \quad \UAnn\]
    \[\UEVarTy\]
    \[\UTyEVar\]
\headercapm{\tctx[\genA] \bycg \tau_1 \cgto \tau_2 \toctx}{Resolve existential variables in $\tau_1$}
    \[\IEVarB\]
    \[\IPi \quad \IOthers\]
    \caption{Unification rules}
    \label{fig:algo-unification}
\end{figure*}

Algorithmic bidirectional typing rules directly follow declarative rules, with existential variables representing unknown types, and a output context. Figure \ref{fig:algo-typing-rules} gives the algorithmic bidirectional typing rules. The interpretation of judgement $\tpreall e:\tau \toctx \trto t$ is, under context $\tctx$, infer expression $e$ (if $\delta = \Inf$), which gives output type $\tau$ and output context $\ctxl$; or check $e$ with type $\tau$ (if $\delta = \Chk$), which gives output context $\ctxl$.

\paragraph{Output context.}
Given a input context, during typing process, new existential variables could be created, useless existential variables could be removed, unsolved existential variables could get solved. The output context of typing is to keep those updates. For example, in the preconditions of rule \rul{Ann}, the first output context will become the input context for next typing.

Before we dive into typing rules, we discuss instantiation and generalization rules first, since typing rules rely on them and they are just natural extension of declarative rules.

\subsubsection{Instantiation and Generalization}

Instantiation turns a type scheme into a monotype by instantiating forall bounds. Unlike declarative system where we guess the types to instantiate, we use existential variables. As shown in the bottom of Figure \ref{fig:algo-typing-rules}, \rul{Inst} substitute the bounds variables with created new existential variables and put them into output context so further typing could refer to those vairables.

In generalization, \rul{Gen} firstly substitutes the context, and extract the free variables to make a polymorphic type. It is very Hindley-Milner way and does not modify the context.

\subsubsection{Typing rules}

We now go through the typing rules.

\rul{T-Ax} and \rul{T-Var} remain standard, where the context has no change. \rul{T-LetVar} relies on the instantiation, and takes the output context of instantiation as output context. \rul{T-Ann} is a natural extensions of the declarative rules with extra interaction with contexts.

\paragraph{Throw out context.}
In \rul{T-Pi}, the context $\ctxr$ after $x$ is thrown because all those variables are out of scope, and all the existential variables in $\ctxr$ will not be refered again when this rule ends. It is safe to throw existential variables because we could assume all unsolved existential variables are solved by $\star$ which satisfys $\star:\star$.

\rul{T-Lam$\Chk$} could be interpreted in the same way.

\paragraph{Typing Dependent Functions.}
In how to type infer abstraction, Dunfield and Krishnaswami use a clever way to give result type an existential variable, and make sure it appears before $x$, so it will not be thrown away while throwing trailing context:

\begin{mathpar}
\OLamInf
\end{mathpar}

It works well when there is no dependency of $\genB$ on $x$. But it is not the case in dependently typed function. Consider expression \lst{\\x:*. \\y:x. y} of type $\bpi x \star {\bpi y x x}$. In the outer lambda, the $\genB$ (which is solved as $\bpi y x x$) will refer to $x$. So instead, we use the normal way to type infer abstraction as shown in the precondition in rule \rul{T-Lam$\Inf$}

However, this brings another problem: \emph{the context after $x$ cannot be simply thrown away, because the function type may have references to the existential variables in the context after $x$}. For example, infering type of expression $\erlam x {\erlam y y}$ will give $\bpi x {\genA_1} {\bpi y {\genA_2} {\genA_2}}$. If we throw away the context after $x$, we will lose the information about $\genA_2$.

To solve this problem, we notice that the result type has two forms of references to the existential variables after $x$, that is, it can refer to a solved one, or it can refer to an unsolved one. For solved variables, we can substitute the context to the result type. And for unsolved variables, we need to preserve them. So one possible solution is to substitute the context to the result type and preserve the unsolved type variables, as shown in the conclusion in rule \rul{T-Lam$\Inf$}. The formal definition of UV (stands for unsolved existential variables) shows as follows:

\begin{mathpar}
    \begin{tabular}{r c l l}
        $UV(\ctxinit)$    & = & $\cdot$       \\
        $UV(\tctx, \genA)$ & = & $UV(\tctx), \genA$ \\
        $UV(\tctx, \_)$     & = & $UV(\tctx)$
    \end{tabular}
\end{mathpar}

We can minimize the context if replace $UV(\ctxr)$ with $UV(\ctxr) \cap FEV([\ctxr]\tau_2)$. Because only those free existential variables appeaering in result type are what we want to preserve.

\paragraph{Application.}
Consider the application rule in declarative system, which assumes $e_1$ is of a Pi type. It is not the case in algorithmic system because the type of $e_1$ could be either a Pi type or an existential variable. We will take both two cases into consideration.

\rul{T-App} first infers the type of $e_1$ to get $\tau_1$, then substitute the context in $\tau_1$ and enter the application typing rules, which is defined by the A-rules. The judgement $\tctx \byapp \tau_1 ~ e : \tau_2 \toctx$ is interpreted as, in context $\tctx$, the type of the expression being applied is $\tau_1$, the argument is $e_2$, and the output of the rule is the application result type $\tau_2$ with context $\ctxl$.

In \rul{A-Pi}, the type of $e_1$ is a Pi type, so it checks $e_2$ with the argument type provided.

In \rul{A-EVar}, the type of $e_1$ is an unsolved existential variable $\genA$. It first destructs $\genA$ into a Pi type, and checks $e_2$ with the new generated existential variable. One notice is that \rul{A-EVar} actually could only resolve non-dependent function type for $\genA$, which means there is no dependency of $x$ in $\genA_2$. For example, expression $\erlam f {(f~nat~1) + (f~\star~nat)}$ will be rejected, because it requests to infer $f$ as a dependently typed function with type $\bpi x \star {\bpi y x} nat$.

\rul{T-Let} first infers the type of the binding, then use \rul{Gen} to do Damas-Milner style polymorphism. When type checking the body, the let binding is added to the context. The result type will be substituted by the context after $x$ and the binding itself.

\rul{T-CastUp} and \rul{T-CastDn} apply the context before reduction because solutions and let definitions influence reduction, then do one-step reduction according to semantic operations.

\rul{T-Sub} shifts the mode, by requesting the inferred type and checked type to be alpha-equal by using unification, which is discussed in next section.

\subsubsection{Unification}

\begin{figure}[h]
    \headercapm{\tctx \byuni \genA \lt A \toctx}{Under input context $\tctx$, instantiate $\genA$ such that $\genA \lt A$, with output context $\ctxl$}
    \[\OInstLSolve\]
    \[\OInstLArr\]
    \[\OInstLReach\]
    \caption{Unification in Dunfield and Krishnaswami's system.}
    \label{fig:origin-unification}
\end{figure}

Figure \ref{fig:algo-unification} defines the unification procedure used in \rul{T-Sub} rule. The judgement $\tpreuni \tau_1 \lt \tau_2 \toctx$ is interpreted as, under context $\tctx$, unify two types $\tau_1$ and $\tau_2$, which gives output context $\ctxl$. One feature of the unification is like Hindley-Milner system: there is no forall in unification procedure, which simplifies unification a lot.

To compare the differences and explain the motivation, Figure \ref{fig:origin-unification} gives the unification rules in Dunfield and Krishnaswami's system when existential variable appears in the left hand side. Here we omit the rule for forall.

Back to Figure \ref{fig:algo-unification}, the first three rules are just identity. The remaining rules except the last two, are structurally defined. They unify each component of the constructor, with context applied before next unification. For rules involving bound variables, $x$ will be added into the context for following unification, and the output context after $x$ will be threw away. Notice the order of $x$ in the context determines the unification $\genA_2 \byuni \bpi x \star \genA_2 \lt \bpi x \star x$ will fail.

The last two rules deal with existential variable case. Consider extending rules in Figure \ref{fig:origin-unification} to dependently typed expression to deal with existential variables, this unification problem would fail:

$\tctx, \genA, \genB, \ctxr \byuni \genA \lt \bpi x \genB x$

Here because $\genB$ appears after $\genA$, so \rul{InstLSolve} cannot be applied. But while trying to use \rul{InstLArr}, we are requesting $\genA_2$ could refer to  $x$. This means we need to add $x$ at least before $\genA_2$ to make $\genA_2$ well typed, which will unfortunately make all the type variables in $\ctxr$ be able to refer to $x$. But this unification do have a solution context: $\tctx, \genA_1, \genA = \bpi x {\genA_1} x, \genB = \genA_1, \ctxr$.

Good news is that we could merge all three rules in Figure \ref{fig:origin-unification} to solve this problem, which results in \rul{U-EvarTy}. Actually, the role of rule \rul{InstLArr} and \rul{InstLReach} is to work for cases that \rul{InstLSolve} cannot handle: some existential variables in the right hand side appear after $\genA$ in context (another case is forall types if type system has forall types).

\paragraph{Resolving existential variables.} The latter part of Figure \ref{fig:algo-unification} defines the I-rules that are used in \rul{U-EvarTy} and \rul{U-TyEVar}. The judgement $\tctx[\genA] \bycg \tau_1 \cgto \tau_2 \toctx$ is interpreted as, under context $\tctx$, try to find all the existential variables $\overbar \genB$ in $\tau_1$ that appears after $\genA$ in context, then generate new existential variables $\overbar {\genA_1}$ before $\genA$ and make $\overbar \genB = \overbar {\genA_1}$. These rules will turn $\tau_1$ into $\tau_2$ where all the existential variables could be refered directly by $\genA$.

\rul{I-EVar} shows the exact process. Because $\genB$ cannot be refered to directly, so we create $\genA_1$ before $\genA$ and make $\genB=\genA_1$ and return $\genA_1$ as result. One interpretation of \rul{I-Evar} rule is that it is the combination of original \rul{InstRArr} and \rul{InstRReach} rules in Dunfield and Krishnaswami's system, which create new type variable and make $\genB$ refer to it. This rule could also be used in Dunfield and Krishnaswami's system, with extra treatment of polymorphism types.

\rul{I-Pi} is to structurally repeat this process. Notice because type scheme is not available in syntax level, Pi is the only constructor where existential variables could appear. So other cases just return $\tau_1$ itself, represented by the single \rul{I-Others}.

Having the I-rules, back to rule \rul{U-EvarTy}. It first does the occur check, and use I-rules to solve the problem of existential variables, at last checks the well termedness of the result. It is easy to see this rule contains \rul{InstLSolve} directly since we have $\tau_1 \cgto \tau_1$. And it contains \rul{InstLArr} and \rul{InstLReach} respectively from \rul{I-Pi} and \rul{I-EVar}. Now this unification problem is solved, which is shown in Figure \ref{fig:algo-solve-unify}.

\begin{figure*}[h]
    $\ctxl = \tctx,\genA_1,\genA,\genB =\genA_1,\ctxr$
    \[\ExUni\]
    \caption{Solve unification problem.}
    \label{fig:algo-solve-unify}
\end{figure*}
