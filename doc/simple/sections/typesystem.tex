\section{Algorithmic Typing}

\subsection{Language}

\begin{figure}[h]
    \begin{tabular}{lrcl}
        Type & $\sigma$ & \syndef & $\forall x:\star. \sigma \mid \tau$ \\

        Expr & $e,\tau$ & \syndef & $x \mid \genA \mid \star \mid e_1~e_2$ \\
        && \synor & $\erlam x e \mid \blam x \tau e \mid \bpi x {\tau_1} \tau_2$ \\
        && \synor & $\kw{let} x=e_1 \kw{in} e_2$ \\
        && \synor & $\ercastup e \mid \castdn e$ \\
        && \synor & $e : \tau$ \\
        Contexts &
        $\ctx,\ctxl,\ctxr$ & \syndef & $\ctxinit$ \\
        && \synor & $\ctx,x \mid \ctx,x:\tau \mid \ctx,x:\sigma=e$ \\
        && \synor & $\ctx,\genA \mid \ctx,\genA=\tau$ \\
        Complete Ctx &
        $\cctx$ & \syndef & $\ctxinit \mid \ctx,x \mid \ctx,x:\tau$ \\
        && \synor & $\ctx,x:\tau=\tau_2$ \\
        && \synor & $\ctx,\genA=\tau$ \\
    \end{tabular}
    \caption{syntax.}
    \label{fig:syntax}
\end{figure}

Figure \ref{fig:syntax} gives the syntax of type and expression, and the definition of context for algorithmic system. The main difference is the existential variable $\genA$, which is quite like unification variables that are waited to be solved. But as context is ordered, unlike unification variables, existential variables also have scopes.

There are two forms of existential variables in context: unsolved form $\genA$ and solved form $\genA=\tau$. Once an existential vairable is solved, its solution will never be changed. The change of corresponding well formedness for existential variables and context are given in Figure \ref{fig:existwellform}.

Now we could extend the definition of context subsitution as shown in Figure \ref{fig:applyctx}. Intuitively, Existential variables in solved form could be substituted by its solution.

\begin{figure}[h]
    \headercapm{\ctx \bywt \sigma}{Well Form of type $\sigma$ under context $\ctx$}

    \[\TWFEVar \quad \TWFPi \]
    \[\TWFPoly \quad \TWFOther \]

    \headercapm{\ctx\wc}{Context $\ctx$ is well formed}

    \[\TWCEmpty \quad \TWCVar\]
    \[\TWCTypedVar\]
    \[\TWCLetVar\]
    \[\TWCEVar\]
    \[\TWCSolvedEVar\]
    \caption{Well formedness with existential variables.}
    \label{fig:existwellform}
\end{figure}

\begin{figure}[t]
    \headercapm{[\ctx]e_1 = e_2}{Apply context to a type}

    \begin{mathpar}
    \begin{tabular}{r c l l}
        $[\ctxinit]e$   & = & $e$       \\
        $[\ctx,x]e$      & = & $[\ctx]e$ \\
        $[\ctx,x:\tau]e$ & = & $[\ctx]e$ \\
        $[\ctx,x:\sigma = \tau]e$ & = & $[\ctx](e[x\mapsto \tau])$ \\
        $[\ctx, \genA]e$ & = & $[\ctx]e$ \\
        $[\ctx, \genA=\tau]e$ & = & $[\ctx](e[\genA \mapsto \tau])$
    \end{tabular}
    \end{mathpar}
    \caption{Applying a context with existential variables.}
    \label{fig:applyctx}
\end{figure}

\paragraph{Hole notation.} We use notations like $\ctx[x]$ to require the variable $x$ appear in the context, sometimes also written as $\ctx_1, x, \ctx_2$. According to this definition, the precondition of \rul{WF-EVar} could be removed and use conclusion $\ctx[\genA] \bywt \genA$.

Multiple holes also require the order. For example, $\ctx[x][\genA]$ not only require the existance of both variable $x$ and $\genA$, and also require $x$ appear before $\genA$.

Hole notation is also used for replace and modification. After an unification, $\ctx[\genA]$ could become $\ctx[\genA = \star]$, which means the context keeps unchanged except $\genA$ now is solved.

\subsection{Typing Rules}

\begin{figure*}[h]
    \headercapm{\preall e:\tau \toctx \trto t}{Expression Typing ($\delta ::= \Inf\mid \Chk$)}
    \[\TAx \quad \TVar\quad \TLetVar\]
    \[\TAnn \quad \TPi\]
    \[\TLamInf \quad \TLamChk\]
    \[\TLamAnnInf \quad \TApp\]
    \[\TLamAnnChk\]
    \[\TLet\]
    \[\TCastUp \quad \TCastDn\]
    \[\TSub\]
    \\
    \headercapm{\preapp \tau_1~e:\tau_2 \toctx \trto t}{Application Typing}
    \[\APi \quad \AEVar\]
    \\
    \headercapm{\preinst \sigma \lt \tau \toctx}{Instantiation} \quad \headercapm{\pregen \tau \lt \sigma}{Generalization}
    \[\Instantiation \quad \Generalization\]
    \caption{Typing rules}
    \label{fig:typingrules}
\end{figure*}

\begin{figure*}[h]
\headercapm{\preuni \tau_1 \lt \tau_2 \toctx}{Unification of Types}
    \[\UVar \quad \UEVarId \quad \UStar\]
    \[\UApp \quad \ULet\]
    \[\ULam \quad \ULamAnn\]
    \[\UCastUp \quad \UCastDn\]
    \[\UPi \quad \UAnn\]
    \[\UEVarTy\]
    \[\UTyEVar\]
\headercapm{\ctx[\genA] \bycg \tau_1 \cgto \tau_2 \toctx}{Resolve existential variables in $\tau_1$}
    \[\IEVarA\]
    \[\IEVarB\]
    \[\IPi \quad \IOthers\]
    \caption{Unification rules}
    \label{fig:unifyrules}
\end{figure*}

Figure \ref{fig:typingrules} gives the algorithmic bidirectional typing rules.

\paragraph{Output context.}
The judgement $\preall e:\tau \toctx \trto t$ is now with output context, which is used mainly for existance records and solutions of existential variables. The interpretation of judgement is, under context $\ctx$, infer expression $e$ (if $\delta = \Inf$), which gives output type $\tau$ and output context $\ctxl$; or check $e$ with type $\tau$ (if $\delta = \Chk$), which gives output context $\ctxl$.

First four typing rules remain stardard as natural extensions of the declarative rules.

\paragraph{Throw out context.}
In \rul{T-Pi}, the context $\ctxr$ after $x$ because all those variables are out of scope, and all the existential variables in $\ctxr$ will not be refered again when this rule ends. It is safe to throw existential variables because we could assume all unsolved existential variables are solved by $\star$ which satisfys $\star:\star$.

\rul{T-Lam$\Chk$} could be interpreted in the same way.

\paragraph{Typing Dependent Functions.}
\rul{T-Lam$\Inf$} shows one difference between our system and Dunfield and Krishnaswami's system which is due to dependent types. Consider the rule for lambda in Dunfield and Krishnaswami's system:

\begin{mathpar}
\OLamInf
\end{mathpar}

Here $\genB$ is generated before $x$ and is used to check the body. It works well when there is no dependency of $\genB$ on $x$. But in dependently typed function, consider expression \lst{\\x:*. \\y:x. y} of type $\bpi x \star {\bpi y x x}$. In the outer lambda, the $\genB$ (which is solved as $\bpi y x x$) will refer to $x$. So the order in the precondition should be $\genA, x:\genA, \genB$. Then the existance of $\genB$ is actually making no difference from the traditional typing rule for lambda, namely infer the type of body under $\genA, x:\genA$. We choose to use the latter one.

\emph{But then we cannot throw the context after $x$, since the result type may have references to the existential variables in the context after $x$}. For example, infering type of expression $\erlam x {\erlam y y}$ will give $\bpi x {\genA_1} {\bpi y {\genA_2} {\genA_2}}$. If we throw away the context after $x$, we will lose the information about $\genA_2$.

The result type has two forms of references to the existential variables after $x$, that is, it can refer to a solved one, or it can refer to an unsolved one. For solved variables, we can substitute the context to the result type. And for unsolved variables, we need to preserve them. So one possible solution is to substitute the context to the result type and preserve the unsolved type variables, as rule \rul{T-Lam$\Inf$} shows. The formal definition of UV (stands for unsolved existential variables) shows as follows:

\begin{mathpar}
    \begin{tabular}{r c l l}
        $UV(\ctxinit)$    & = & $\cdot$       \\
        $UV(\ctx, \genA)$ & = & $UV(\ctx), \genA$ \\
        $UV(\ctx, \_)$     & = & $UV(\ctx)$
    \end{tabular}
\end{mathpar}

We can minimize the context if replace $UV(\ctxr)$ with $UV(\ctxr) \cap FV([\ctxr]\tau_2)$, where FV stands for free existential variables. Because it is only the free existential variables in result type are what we want to preserve.

\rul{T-LamAnn} uses the same methodology.

\paragraph{Application.}
Consider the application rule in declarative system, which assumes $e_1$ is of a Pi type. It is not the case in algorithmic system because the type of $e_1$ could be an existential variable.

\rul{T-App} first infers the type of $e_1$ to get $\tau_1$, then substitute the context in $\tau_1$ and enter the application typing rules, which is defined by the A-rules. The judgement $\ctx \byapp \tau_1 ~ e : \tau_2 \toctx$ is interpreted as, in context $\ctx$, the type of the expression being applied is $\tau_1$, the argument is $e_2$, and the output of the rule is the application result type $\tau_2$ with context $\ctxl$.

In \rul{A-Pi}, the type of $e_1$ is a Pi type, so it checks $e_2$ with the argument type provided.

In \rul{A-EVar}, the type of $e_1$ is an unsolved existential variable $\genA$. It first destructs $\genA$ into a Pi type, and checks $e_2$ with the new generated existential variable. One notice is that \rul{A-EVar} actually could only resolve non-dependent function type for $\genA$, which means there is no dependency of $x$ in $\genA_2$. For example, expression $\erlam f {(f~nat~1) + (f~\star~nat)}$ will be rejected, because it requests to infer $f$ as a dependently typed function with type $\bpi x \star {\bpi y x} nat$.

\rul{T-Let} first infers the type of the binding, then use \rul{Gen} to do Damas-Milner style polymorphism. When type checking the body, the let binding is added to the context. The result type will be substituted by the context after $x$ and the binding itself.

\rul{T-CastUp} and \rul{T-CastDn} will apply the context before reduction.

\rul{T-Sub} requests the two types to be alpha-equal by using unification.

At last, \rul{Inst} turns a polymorphic type into a monotype by instantiating all the variables bound by forall to new existential variables. \rul{Gen} substitutes the context before generalization, and extract the free variables to make a polymorphic type. We could delete $\overbar{\genA}$ from context because they are of no use.

\subsection{Unification}

\begin{figure}[h]
    \headercapm{\ctx \byuni \genA \lt A \toctx}{Under input context $\ctx$, instantiate $\genA$ such that $\genA \lt A$, with output context $\ctxl$}
    \[\OInstLSolve\]
    \[\OInstLArr\]
    \[\OInstLReach\]
    \caption{Unification in Dunfield and Krishnaswami's system.}
    \label{fig:originunification}
\end{figure}

Figure \ref{fig:unifyrules} defines the unification procedure used in \rul{T-Sub} rule. The judgement $\preuni \tau_1 \lt \tau_2 \toctx$ is interpreted as, under context $\ctx$, unify two types $\tau_1$ and $\tau_2$, which gives output context $\ctxl$. One feature of the unification is like Hindley-Milner system: there is no forall in unification procedure, which simplifies unification a lot.

To compare the differences and explain the motivation, Figure \ref{fig:originunification} gives the unification rules in Dunfield and Krishnaswami's system when existential variable appears in the left hand side. Here we omit the rule for forall.

Back to Figure \ref{fig:unifyrules}, the first three rules are just identity. The remaining rules except the last two, are structurally defined. They unify each component of the constructor, with context applied before next unification. For rules involving bound variables, $x$ will be added into the context for following unification, and the output context after $x$ will be threw away. Notice the order of $x$ in the context determines the unification $\genA_2 \byuni \bpi x \star \genA_2 \lt \bpi x \star x$ will fail.

The last two rules deal with existential variable case. Consider extending rules in Figure \ref{fig:originunification} to dependently typed expression to deal with existential variables, this unification problem would fail:

$\ctx, \genA, \genB, \ctxr \byuni \genA \lt \bpi x \genB x$

Here because $\genB$ appears after $\genA$, so \rul{InstLSolve} cannot be applied. But while trying to use \rul{InstLArr}, we are requesting $\genA_2$ could refer to  $x$. This means we need to add $x$ at least before $\genA_2$ to make $\genA_2$ well typed, which will unfortunately make all the type variables in $\ctxr$ be able to refer to $x$. But this unification do have a solution context: $\ctx, \genA_1, \genA = \bpi x {\genA_1} x, \genB = \genA_1, \ctxr$.

Good news is that we could merge all three rules in Figure \ref{fig:originunification} to solve this problem, which results in \rul{U-EvarTy}. Actually, the role of rule \rul{InstLArr} and \rul{InstLReach} is to work for cases that \rul{InstLSolve} cannot handle: some existential variables in the right hand side appear after $\genA$ in context (another case is forall types if type system has forall types).

\paragraph{Resolving existential variables.} The latter part of Figure \ref{fig:unifyrules} defines the I-rules that are used in \rul{U-EvarTy} and \rul{U-TyEVar}. The judgement $\ctx[\genA] \bycg \tau_1 \cgto \tau_2 \toctx$ is interpreted as, under context $\ctx$, try to find all the existential variables $\overbar \genB$ in $\tau_1$ that appears after $\genA$ in context, then generate new existential variables $\overbar {\genA_1}$ before $\genA$ and make $\overbar \genB = \overbar {\genA_1}$. These rules will turn $\tau_1$ into $\tau_2$ where all the existential variables could be refered directly by $\genA$.

\rul{I-Var} and \rul{I-Star} is just identity.

\rul{I-EVar1} is when $\genB$ appears before $\genA$, then $\genA$ could refer it directly so it is safe to remain it.

In \rul{I-EVar2}, because $\genB$ cannot be refered to directly, so we create $\genA_1$ before $\genA$ and make $\genB=\genA_1$ and return $\genA_1$ as result. One interpretation of I-Evar2 rule is that it is the combination of original \rul{InstRArr} and \rul{InstRReach} rules in Dunfield and Krishnaswami's system, which create new type variable and make $\genB$ refer to it. This rule could also be used in Dunfield and Krishnaswami's system, with extra treatment of polymorphism types.

Other cases are structurally defined, so they are represented by the single \rul{I-Others}.

Having the I-rules, back to rule \rul{U-EvarTy}. It first does the occur check, and use I-rules to solve the problem of existential variables, at last checks the well typedness of the result. It is easy to see this rule contains \rul{InstLSolve} directly since we have $\tau_1 \cgto \tau_1$. And it contains \rul{InstLArr} and \rul{InstLReach} respectively from \rul{I-Other} and \rul{I-EVar2}. Now this unification problem is solved, which is shown in Figure \ref{fig:solveunify}.

\begin{figure*}[h]
    $\ctxl = \ctx,\genA_1,\genA,\genB =\genA_1,\ctxr$
    \[\ExUni\]
    \caption{Solve unification problem.}
    \label{fig:solveunify}
\end{figure*}
