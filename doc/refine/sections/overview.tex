\section{Overview}

This section provides background and gives an overview of our work.

\subsection{Background and Motivation}

\subsubsection{Type Inference In Context.}

\citet{gundry2010type} models unification and type inference from a general
perspective of information increase in the problem context, based on the
invariant that types can only depend on bindings appearing earlier in the
context.

Specifically, information and constraints about variables are stored in the
context, which is a list maintaining information order. For example\footnote{We
  adopt our notations and terminologies for the examples}:

$\tctx_1 = \genA, f, \genB, t :\genB \to \genB$

Here $\genA, \genB$ are existential variables waiting to be solved, whose
meaning is given by solutions:

$\tctx_2 = \genA, f, \genB = \Int, t :\genB \to \genB$

Then unification problem becomes finding a more informative context that
contains solutions for the existential variables so that two expressions are
equivalent up to substitution of the solutions for existential variables. For
example, $\tctx_2$ can be the solution context for unifying
$\Int$ and $\genB$ under $\tctx_1$.

Beside contexts being ordered, a key design of the approach is when unify
existential variables with other types. In this case, unification needs to
resolve the dependency between existential variables, for example, unify $\genA$
with $\genB \to \genB$ under context $\genA, f, \genB, t : \genB \to \genB$.
Here $\genB$ is out of the scope of $\genA$. The way they
solve it is to examine variables in the context from the tail to the head,
\textit{moves segments of context to the left if necessary}, until the
existential variable being unified is found. This design is implemented by an
additional context that the unification takes with it. This can be interpreted
from judgment $\tctx \ctxsplit \Xi \byuni \genA \equiv \tau \toctx$, which is
read as: given input context $\tctx$, $\Xi$, solve $\genA$ with $\tau$ succeeds
and produce an output context $\ctxl$.

The key rules involving in the process is given in
Figure~\ref{fig:inference-context}. If a variable is useless for the
unification, it is ignored (\rul{Ignore}). Otherwise, if the variable is needed,
but it is out of the scope of $\genA$, then it is moved to the additional
context (\rul{Depend}). Finally we arrive at the variable we want to unify,
which is $\genA$, we then insert the additional context before $\genA$, and
solve $\genA = \tau$ (\rul{Define}). Therefore, the output context for the above
unification problem is $\genB, \genA = \genB \to \genB, f, t: \genB \to \genB$.
Note that $\genB$ is moved to the front of $\genA$.

\begin{figure*}[t]
  \begin{mathpar}
    % \framebox{$\tctx \bybuni \sigma_1 \uni \sigma_2 \toctx$} \\
    \Ignore \and \Depend \and \Define
  \end{mathpar}
  \caption{Unification between an existential variable and a type (incomplete).}
  \label{fig:inference-context}
\end{figure*}

\paragraph{Challenges.}

Moving type variables around is a feasible way to resolve the dependency between
existential variables. However, the unpredictable context movements make the
information increase hard to formalize and reason about. In this sense, the
information increase of contexts is defined in a much \textit{semantic} way:
$\ctxl$ is more informative than $\tctx$, if there exists a substitution $S$
that for every $v \in \tctx$, we have $\ctxl \bywf S(v)$.

This semantic definition makes it hard to prove meta-theory formally, especially
when advanced features are involved. For example, in dependent type systems,
typing and types/contexts well-formedness are usually coupled, which makes proof
even more complicated.

\subsubsection{Application in Higher Rank Type System.}

\begin{figure*}[t]
  \begin{mathpar}
    % \framebox{$\tctx \bybuni \sigma_1 \uni \sigma_2 \toctx$} \\
    \InstLSolve \and \InstLReach \and \InstLArr
    \and \InstRReach
  \end{mathpar}
  \caption{Instantiation between an existential variable and a type (incomplete).}
  \label{fig:instantiation}
\end{figure*}

\citet{dunfield2013complete} also use ordered contexts as input and output for
type inference for a higher rank type system. However, they do it in a more
\textit{syntactic} way.

Instead of moving variables to the left in the context, in their subtyping
between existential variable and a type, which they call instantiation, they
choose to destruct type constructors so that existential variables can be
unified individually, then there are only two cases to discuss: whether the left
existential variable appears first, or the right one appears first.
Specifically, Figure~\ref{fig:instantiation} shows the key idea of instantiation
rules between an existential variable and a type. For space reason, we only
present the rules when the left hand side is an existential variables; but the
other cases are quite symmetric. We save the formal explanations for notations
later to Section~\ref{sec:dependent}. Notice in \rul{InstLArr}, the existential
variable $\genA$ is solved by a function type consisting of two fresh
existential variables, and then the function is destructed to do instantiation
successively. And \rul{InstLReach} and \rul{InstRReach} deals with the order
problem easily.

In this way, the information increase of contexts, which they call context
extension, is formalized in an intuitive and straightforward \textit{syntactic}
way, which enables them to prove the meta-theory in a thorough and formal way.
Due to the space limitation, the definition of context extension can be found in
appendix. Our definition shown in Section~\ref{sec:context-extension} also
mimics their definition.

\paragraph{Challenges.} While destructing type constructors makes perfect sense
in their setting, it cannot deal with dependent types correctly. For example,
given the context $\genA, \genB$ and we want to unify $\genA$ with a dependent
type $\bpi x \genB x$. Here because $\genB$ appears after $\genA$, we cannot
directly derive $\genA = \bpi x \genB x$ which is ill typed. However, if we try
to destruct this Pi type, then according to rule \rul{InstLArr}, it is obvious
that $\genA_2$ should be solved by $x$. In order to make the solution well
typed, we need to put $x$ before $\genA_2$ into the context. However, this means
$x$ will remain in the context, and it is available for any later existential
variable that should not have access to $x$.

Also, destruction creates symmetric rules, for example, the rules in
Figure~\ref{fig:instantiation} is repeated for the cases when the existential
variable is on the right. For example, there is a corresponding \rul{InstRArr}
for the case the existential duplication This kind of ``duplication'' would grow
with the increase of type constructors.

\subsection{Type Sanitization}

\subsection{Generalize Instantiation}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% org-ref-default-bibliography: "citation.bib"
%%% End: